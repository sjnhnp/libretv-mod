<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>播放器</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="css/styles.css">
    <style>
      body, html { margin: 0; padding: 0; width: 100%; height:100%; background:#0f1622; color:white;}
      .player-container { width:100%; max-width:1200px; margin:0 auto;}
      #player { width:100%; height:60vh;}
      .loading-container {position:absolute;top:0;left:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center;
        background-color:rgba(0,0,0,0.7);color:white;z-index:100;flex-direction:column;}
      .loading-spinner {width:50px;height:50px;border:4px solid rgba(255,255,255,0.3);border-radius:50%;border-top-color:white;
        animation:spin 1s ease-in-out infinite;margin-bottom:10px;}
      @keyframes spin { to {transform:rotate(360deg);} }
      .error-container {position:absolute;top:0;left:0;right:0;bottom:0;display:none;align-items:center;justify-content:center;
        background:rgba(0,0,0,0.7);color:white;z-index:100;flex-direction:column;text-align:center;padding:1rem;}
      .error-icon { font-size:48px;margin-bottom:10px;}
      .episode-active {background:#3b82f6 !important; border-color:#60a5fa !important;}
      .episode-grid {max-height:30vh;overflow-y:auto;padding:1rem 0;}
      .switch {position:relative;display:inline-block;width:46px;height:24px;}
      .switch input {opacity:0;width:0;height:0;}
      .slider {position:absolute; cursor:pointer; top:0; left:0; right:0; bottom:0;
        background-color:#333;transition:.4s;border-radius:24px;}
      .slider:before {position:absolute;content:"";height:18px;width:18px;left:3px;bottom:3px;background:white;transition:.4s;
        border-radius:50%;}
      input:checked + .slider { background-color:#00ccff;}
      input:checked + .slider:before {transform:translateX(22px);}
      .shortcut-hint {position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);
        background:rgba(0,0,0,0.8);color:white;padding:1rem 2rem;border-radius:0.5rem;
        font-size:1.5rem;display:flex;align-items:center;gap:0.5rem;z-index:1000;opacity:0;transition:opacity 0.3s;}
      .shortcut-hint.show {opacity:1;}
      .player-container:-webkit-full-screen, .player-container:fullscreen {
        position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:10000;background:#000;}
      .player-container:-webkit-full-screen #player, .player-container:fullscreen #player {width:100%;height:100%;}
    </style>
</head>
<body>
  <header class="bg-[#111] p-4 flex justify-between items-center border-b border-[#333]">
      <div class="flex items-center">
          <a href="index.html" class="flex items-center" aria-label="返回首页">
              <svg class="w-8 h-8 mr-2 text-[#00ccff]" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
              </svg>
              <h1 class="text-xl font-bold gradient-text">X</h1>
          </a>
      </div>
      <h2 id="videoTitle" class="text-xl font-semibold truncate flex-1 text-center"></h2>
      <a href="index.html" class="px-4 py-2 bg-[#222] hover:bg-[#333] border border-[#333] rounded-lg transition-colors" aria-label="返回首页">
          返回首页
      </a>
  </header>
  <main class="container mx-auto px-4 py-4" aria-label="播放器页面主体">
      <div id="playerContainer" class="player-container">
          <div class="relative">
              <div id="player"></div>
              <div class="loading-container" id="loading" aria-live="polite">
                  <div class="loading-spinner"></div>
                  <div>正在加载视频...</div>
              </div>
              <div class="error-container" id="error" role="alert">
                  <div class="error-icon" aria-hidden="true">⚠️</div>
                  <div id="error-message">视频加载失败</div>
                  <div style="margin-top: 10px; font-size: 14px; color: #aaa;">请尝试其他视频源或稍后重试</div>
              </div>
          </div>
      </div>
      <nav class="player-container" aria-label="剧集导航">
          <div class="flex justify-between items-center my-4">
              <button onclick="playPreviousEpisode()" id="prevButton" aria-label="上一集" class="px-4 py-2 bg-[#222] hover:bg-[#333] border border-[#333] rounded-lg transition-colors">
                  <svg class="w-5 h-5 inline-block" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
                  </svg>
                  上一集
              </button>
              <span class="text-gray-400" id="episodeInfo">加载中...</span>
              <button onclick="playNextEpisode()" id="nextButton" aria-label="下一集" class="px-4 py-2 bg-[#222] hover:bg-[#333] border border-[#333] rounded-lg transition-colors">
                  下一集
                  <svg class="w-5 h-5 inline-block" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                  </svg>
              </button>
          </div>
      </nav>
      <section class="player-container" aria-label="播放设置">
          <div class="flex justify-end items-center mb-4 gap-2">
              <span class="text-gray-400 text-sm">自动连播</span>
              <label class="switch" aria-label="自动连播开关">
                  <input type="checkbox" id="autoplayToggle" aria-checked="true">
                  <span class="slider"></span>
              </label>
              <button onclick="toggleEpisodeOrder()" class="ml-4 px-4 py-2 bg-gradient-to-r from-indigo-500 via-purple-500 to-pink-500 text-white font-semibold rounded-full shadow-lg hover:shadow-xl transition-all duration-300 flex items-center justify-center space-x-2" aria-label="切换排序">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" id="orderIcon" viewBox="0 0 20 20" fill="currentColor">
                      <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-11a1 1 0 10-2 0v3.586L7.707 9.293a1 1 0 00-1.414 1.414l3 3a1 1 0 001.414 0l3-3a1 1 0 00-1.414-1.414L11 10.586V7z" clip-rule="evenodd" />
                  </svg>
                  <span id="orderText">倒序排列</span>
              </button>
              <button id="lockToggle" onclick="toggleControlsLock()" aria-label="锁定/解锁控制区" title="锁定控制"
                      class="px-2 py-1 bg-[#333] hover:bg-[#444] text-white rounded-full transition">
                  <svg id="lockIcon" class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"></svg>
              </button>
          </div>
      </section>
      <section class="player-container" aria-label="集数选择">
          <div class="episode-grid" id="episodesGrid">
              <div class="grid grid-cols-2 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-8 gap-2" id="episodesList">
                  <div class="col-span-full text-center text-gray-400 py-8">加载中...</div>
              </div>
          </div>
      </section>
  </main>
  <div class="shortcut-hint" id="shortcutHint" aria-live="polite" aria-atomic="true">
      <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" id="shortcutIcon"></svg>
      <span id="shortcutText"></span>
  </div>
  <script src="https://s4.zstatic.net/ajax/libs/hls.js/1.5.6/hls.min.js" crossorigin="anonymous"></script>
  <script src="https://s4.zstatic.net/ajax/libs/dplayer/1.26.0/DPlayer.min.js" crossorigin="anonymous"></script>
  <script src="js/config.js"></script>
  <script src="js/main.js"></script>
  <!-- 主播放器及全部功能脚本（优化合并） -->
  <script>
(() => {
  "use strict";
  // ---- 状态集中管理 ----
  const state = {
    currentVideoTitle: '',
    currentEpisodeIndex: 0,
    currentEpisodes: [],
    episodesReversed: false,
    dp: null,
    currentHls: null,
    autoplayEnabled: true,
    adFilteringEnabled: true,
    isUserSeeking: false,
    videoHasEnded: false,
    userClickedPosition: null,
    shortcutHintTimeout: null,
    progressSaveInterval: null,
    controlsLocked: false,
    // 直接读取配置供调试、预加载使用
    debugMode: typeof PLAYER_CONFIG !== 'undefined' && PLAYER_CONFIG.debugMode === true
  };

  // ---- 工具函数 ----
  function qs(id) { return document.getElementById(id); }
  function parseEpisodes(episodesList) {
    try { return JSON.parse(decodeURIComponent(episodesList)); } catch { return []; }
  }
  function safeParseJSON(str, fallback = []) {
    try { return JSON.parse(str); } catch { return fallback; }
  }
  function formatTime(seconds) {
    if (isNaN(seconds)) return '00:00';
    const m = Math.floor(seconds / 60);
    const s = Math.floor(seconds % 60);
    return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
  }
  function getVideoId() {
    return `${encodeURIComponent(state.currentVideoTitle)}_${state.currentEpisodeIndex}`;
  }

  // ---- DOM INIT ON LOAD ----
  document.addEventListener('DOMContentLoaded', () => {
    const urlParams = new URLSearchParams(window.location.search);
    const videoUrl = urlParams.get('url');
    const title = urlParams.get('title');
    let index = parseInt(urlParams.get('index') || '0');
    const episodesList = urlParams.get('episodes');
    // 恢复状态
    state.currentVideoTitle =
      title || localStorage.getItem('currentVideoTitle') || '未知视频';
    // Assign to window global for potential external access/debugging; internal logic uses state.currentVideoTitle.
    window.currentVideoTitle = state.currentVideoTitle;

    state.currentEpisodeIndex = index;
    // Assign to window global for potential external access/debugging; internal logic uses state.currentEpisodeIndex.
    window.currentEpisodeIndex = state.currentEpisodeIndex;

    state.autoplayEnabled = localStorage.getItem('autoplayEnabled') !== 'false';
    state.adFilteringEnabled = localStorage.getItem(PLAYER_CONFIG?.adFilteringStorage) !== 'false';
    qs('autoplayToggle').checked = state.autoplayEnabled;
    qs('autoplayToggle').addEventListener('change', e => {
      state.autoplayEnabled = e.target.checked;
      localStorage.setItem('autoplayEnabled', state.autoplayEnabled);
    });
    // 剧集获取
    try {
      if (episodesList) {
        state.currentEpisodes = parseEpisodes(episodesList);
      } else {
        state.currentEpisodes = safeParseJSON(localStorage.getItem('currentEpisodes'), []);
      }
      // Assign to window global for potential external access/debugging; internal logic uses state.currentEpisodes.
      window.currentEpisodes = state.currentEpisodes;
      if (index < 0 || (state.currentEpisodes.length > 0 && index >= state.currentEpisodes.length)) {
        index = Math.max(0, Math.min(state.currentEpisodes.length - 1, index));
        const newUrl = new URL(window.location.href);
        newUrl.searchParams.set('index', index);
        window.history.replaceState({}, '', newUrl);
      }
      state.currentEpisodeIndex = index;
      window.currentEpisodeIndex = index; // see note above
      state.episodesReversed = localStorage.getItem('episodesReversed') === 'true';
    } catch {
      state.currentEpisodes = [];
      window.currentEpisodes = [];
      state.currentEpisodeIndex = 0;
      window.currentEpisodeIndex = 0;
      state.episodesReversed = false;
    }
      // 标题
      document.title = state.currentVideoTitle + ' - 播放器';
      qs('videoTitle').textContent = state.currentVideoTitle;
      // 初始化播放器
      if (videoUrl) {
        initPlayer(videoUrl);
        // 恢复播放位置
        const pos = urlParams.get('position');
        if (pos) {
          setTimeout(() => {
            if (state.dp && state.dp.video) {
              const p = parseInt(pos);
              if (!isNaN(p) && p > 0) {
                state.dp.seek(p);
                showPositionRestoreHint(p);
              }
            }
          }, 1500);
        }
      } else {
        showError('无效的视频链接');
      }
      updateEpisodeInfo();
      renderEpisodes();
      updateButtonStates();
      updateOrderButton();
      setTimeout(setupProgressBarPreciseClicks, 1000);
      document.addEventListener('keydown', handleKeyboardShortcuts);
      window.addEventListener('beforeunload', saveCurrentProgress);
      document.addEventListener('visibilitychange', onVisibilityChange);
      subscribeVideoEvents();
    });
    // ---- 播放器和事件处理 ----
    function initPlayer(videoUrl) {
      if (!videoUrl) return;
      removeProgressSaveTimer();
      const hlsConfig = {
        debug: false,
        loader: state.adFilteringEnabled ? CustomHlsJsLoader : Hls.DefaultConfig.loader,
        enableWorker: true,
        lowLatencyMode: false,
        backBufferLength: 90, maxBufferLength: 30, maxMaxBufferLength: 60,
        maxBufferSize: 30 * 1000 * 1000, maxBufferHole: 0.5,
        fragLoadingMaxRetry: 6, fragLoadingMaxRetryTimeout: 64000, fragLoadingRetryDelay: 1000,
        manifestLoadingMaxRetry: 3, manifestLoadingRetryDelay: 1000,
        levelLoadingMaxRetry: 4, levelLoadingRetryDelay: 1000,
        startLevel: -1,
        abrEwmaDefaultEstimate: 500000,
        abrBandWidthFactor: 0.95, abrBandWidthUpFactor: 0.7, abrMaxWithRealBitrate: true,
        stretchShortVideoTrack: true,
        appendErrorMaxRetry: 5,
        liveSyncDurationCount: 3, liveDurationInfinity: false,
      };
      const dp = new DPlayer({
        container: qs('player'),
        autoplay: true, theme: '#00ccff', preload: 'auto', loop: false,
        lang: 'zh-cn', hotkey: true, mutex: true, volume: 0.7,
        playbackSpeed: [0.5, 0.75, 1, 1.25, 1.5, 2], screenshot: true,
        preventClickToggle: true, airplay: true, chromecast: true,
        video: {
          url: videoUrl,
          type: 'hls',
          pic: 'https://img.picgo.net/2025/04/12/image362e7d38b4af4a74.png',
          customType: {
            hls: function(video, player) {
              if (state.currentHls && state.currentHls.destroy) {
                try { state.currentHls.destroy(); } catch(ex) {}
              }
              const hls = new Hls(hlsConfig);
              state.currentHls = hls;
              video.addEventListener('playing', () => {
                qs('loading').style.display = 'none';
                qs('error').style.display = 'none';
              });
              video.addEventListener('timeupdate', () => {
                if (video.currentTime > 1) qs('error').style.display = 'none';
              });
              hls.loadSource(video.src); hls.attachMedia(video);
              hls.on(Hls.Events.MANIFEST_PARSED, () => { video.play().catch(()=>{}); });
              hls.on(Hls.Events.ERROR, (event, data) => { handleHlsError(event, data, hls, video, player); });
              hls.on(Hls.Events.FRAG_LOADED, () => { qs('loading').style.display = 'none'; });
              hls.on(Hls.Events.LEVEL_LOADED, () => { qs('loading').style.display = 'none'; });
            }
          }
        }
      });
      state.dp = dp;
      window.dp = dp;
      // 全屏锁定逻辑
      const fsContainer = qs('playerContainer');
      dp.on('fullscreen', () => {
        if (window.screen.orientation && window.screen.orientation.lock) {
          window.screen.orientation.lock('landscape').catch(()=>{});
        }
        fsContainer.requestFullscreen?.().catch(()=>{});
      });
      dp.on('fullscreen_cancel', () => {
        document.exitFullscreen?.();
        window.screen.orientation?.unlock?.();
      });
      dp.on('loadedmetadata', () => {
        qs('loading').style.display = 'none';
        state.videoHasEnded = false;
        setupProgressBarPreciseClicks();
        setTimeout(saveToHistory, 3000);
        startProgressSaveTimer();
      });
      dp.on('error', () => {
        if (dp.video && dp.video.currentTime > 1) return;
        showError('视频播放失败，请检查视频源或网络连接');
      });
      dp.on('ended', () => {
        state.videoHasEnded = true;
        clearVideoProgress();
        if (state.autoplayEnabled && state.currentEpisodeIndex < state.currentEpisodes.length - 1) {
          setTimeout(() => {
            if (state.videoHasEnded && !state.isUserSeeking) playNextEpisode();
            state.videoHasEnded = false;
          }, 1000);
        }
      });
      dp.on('seeking', () => { state.isUserSeeking = true; });
      dp.on('seeked', () => { setTimeout(() => { state.isUserSeeking = false; }, 200); });
      setTimeout(() => {
        if (dp && dp.video && dp.video.currentTime > 0) return;
        if (qs('loading').style.display !== 'none') {
          qs('loading').innerHTML = '<div class="loading-spinner"></div><div>视频加载时间较长，请耐心等待...</div><div style="font-size: 12px; color: #aaa; margin-top: 10px;">如长时间无响应，请尝试其他视频源</div>';
        }
      }, 10000);
    }
    function handleHlsError(event, data, hls, video, player) {
      if (data.fatal) {
        switch (data.type) {
          case Hls.ErrorTypes.NETWORK_ERROR: hls.startLoad(); break;
          case Hls.ErrorTypes.MEDIA_ERROR: hls.recoverMediaError(); break;
          default:
            showError('视频加载失败，可能是格式不兼容或源不可用');
            break;
        }
      }
    }
    class CustomHlsJsLoader extends Hls.DefaultConfig.loader {
      constructor(config) {
        super(config);
        const origLoad = this.load.bind(this);
        this.load = function(context, config, callbacks) {
          if (context.type === 'manifest' || context.type === 'level') {
            const origSuccess = callbacks.onSuccess;
            callbacks.onSuccess = function(response, stats, context) {
              if (response.data && typeof response.data === 'string') {
                response.data = filterAdsFromM3U8(response.data);
              }
              return origSuccess(response, stats, context);
            }
          }
          origLoad(context, config, callbacks);
        }
      }
    }
    function filterAdsFromM3U8(m3u8Content) {
      if (!m3u8Content) return '';
      return m3u8Content.split('\n').filter(line => !line.includes('#EXT-X-DISCONTINUITY')).join('\n');
    }
    // ========== 集数、按钮、切换 ==========
    window.playEpisode = function(index) {
      if (index < 0 || index >= state.currentEpisodes.length) return;
      saveCurrentProgress();
      removeProgressSaveTimer();
      qs('error').style.display = 'none';
      qs('loading').style.display = 'flex';
      qs('loading').innerHTML = '<div class="loading-spinner"></div><div>正在加载视频...</div>';
      state.currentEpisodeIndex = index;
      window.currentEpisodeIndex = index;
      window.history.pushState({}, '', updateQueryUrl({ index, url: state.currentEpisodes[index] }));
      if (state.dp) {
        try {
          state.dp.switchVideo({ url: state.currentEpisodes[index], type: 'hls' });
          state.dp.play().catch(() => { initPlayer(state.currentEpisodes[index]); });
        } catch {
          initPlayer(state.currentEpisodes[index]);
        }
      } else {
        initPlayer(state.currentEpisodes[index]);
      }
      updateEpisodeInfo();
      updateButtonStates();
      renderEpisodes();
      state.userClickedPosition = null;
      setTimeout(saveToHistory, 3000);
    };
    window.playPreviousEpisode = () => playEpisode(state.currentEpisodeIndex - 1);
    window.playNextEpisode = () => playEpisode(state.currentEpisodeIndex + 1);
    window.toggleEpisodeOrder = function() {
      state.episodesReversed = !state.episodesReversed;
      localStorage.setItem('episodesReversed', state.episodesReversed);
      renderEpisodes();
      updateOrderButton();
    };
    window.toggleControlsLock = function() {
      const container = qs('playerContainer');
      state.controlsLocked = !state.controlsLocked;
      container.classList.toggle('controls-locked', state.controlsLocked);
      // 锁图标省略
    };
    function renderEpisodes() {
      const parent = qs('episodesList');
      if (!parent) return;
      if (!state.currentEpisodes || state.currentEpisodes.length === 0) {
        parent.innerHTML = `<div class="col-span-full text-center text-gray-400 py-8">没有可用的集数</div>`;
        return;
      }
      const episodes = state.episodesReversed ? [...state.currentEpisodes].reverse() : state.currentEpisodes;
      const frag = document.createDocumentFragment();
      episodes.forEach((ep, idx) => {
        const realIndex = state.episodesReversed ? state.currentEpisodes.length - 1 - idx : idx;
        const btn = document.createElement('button');
        btn.id = `episode-${realIndex}`;
        btn.onclick = () => window.playEpisode(realIndex);
        btn.className = `px-4 py-2 ${realIndex === state.currentEpisodeIndex ? 'episode-active border-blue-500' : 'bg-[#222] hover:bg-[#333] border-[#333]'} border rounded-lg transition-colors text-center episode-btn`;
        btn.textContent = `第${realIndex + 1}集`;
        if (realIndex === state.currentEpisodeIndex) btn.setAttribute('aria-current', 'true');
        frag.appendChild(btn);
      });
      parent.innerHTML = '';
      parent.appendChild(frag);
    }
    function updateEpisodeInfo() {
      qs('episodeInfo').textContent = state.currentEpisodes.length > 0
        ? `第 ${state.currentEpisodeIndex + 1}/${state.currentEpisodes.length} 集`
        : '无集数信息';
    }
    function updateButtonStates() {
      const prevButton = qs('prevButton'), nextButton = qs('nextButton');
      updateButton(prevButton, state.currentEpisodeIndex > 0);
      updateButton(nextButton, state.currentEpisodeIndex < state.currentEpisodes.length - 1);
    }
    function updateButton(btn, enabled) {
      if (enabled) {
        btn.classList.remove('bg-gray-700', 'cursor-not-allowed');
        btn.classList.add('bg-[#222]', 'hover:bg-[#333]');
        btn.removeAttribute('disabled');
      } else {
        btn.classList.add('bg-gray-700', 'cursor-not-allowed');
        btn.classList.remove('bg-[#222]', 'hover:bg-[#333]');
        btn.setAttribute('disabled', '');
      }
    }
    function updateOrderButton() {
      const orderText = qs('orderText'), orderIcon = qs('orderIcon');
      orderText.textContent = state.episodesReversed ? '正序排列' : '倒序排列';
      orderIcon.style.transform = state.episodesReversed ? 'rotate(180deg)' : '';
    }
    // ========== 键盘和辅助UI ==========
    function handleKeyboardShortcuts(e) {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
      if (e.altKey && e.key === 'ArrowLeft' && state.currentEpisodeIndex > 0) {
        window.playPreviousEpisode(); showShortcutHint('上一集', 'left'); e.preventDefault();
      }
      if (e.altKey && e.key === 'ArrowRight' && state.currentEpisodeIndex < state.currentEpisodes.length - 1) {
        window.playNextEpisode(); showShortcutHint('下一集', 'right'); e.preventDefault();
      }
    }
    function showShortcutHint(text, dir) {
      const hint = qs('shortcutHint'), textEl = qs('shortcutText'), iconEl = qs('shortcutIcon');
      clearTimeout(state.shortcutHintTimeout);
      textEl.textContent = text;
      iconEl.innerHTML = dir === 'left'
        ? '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>'
        : '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>';
      hint.classList.add('show');
      state.shortcutHintTimeout = setTimeout(() => hint.classList.remove('show'), 2000);
    }
    // ========== 进度、历史、错误、其它 ==========
    function saveToHistory() {
      if (!state.currentEpisodes?.length) return;
      const urlParams = new URLSearchParams(window.location.search);
      const sourceName = urlParams.get('source') || '';
      let currentPosition = 0, videoDuration = 0;
      if (state.dp && state.dp.video) {
        currentPosition = state.dp.video.currentTime;
        videoDuration = state.dp.video.duration;
      }
      const videoInfo = {
        title: state.currentVideoTitle,
        url: `player.html?title=${encodeURIComponent(state.currentVideoTitle)}&source=${encodeURIComponent(sourceName)}`,
        episodeIndex: state.currentEpisodeIndex,
        sourceName,
        timestamp: Date.now(),
        playbackPosition: currentPosition > 10 ? currentPosition : 0,
        duration: videoDuration,
        episodes: [...state.currentEpisodes],
      };
      if (typeof window.addToViewingHistory === 'function') {
        window.addToViewingHistory(videoInfo);
      } else {
        try {
          const history = safeParseJSON(localStorage.getItem('viewingHistory'), []);
          const existingIndex = history.findIndex(item => item.title === videoInfo.title);
          if (existingIndex !== -1) {
            const item = history.splice(existingIndex, 1)[0];
            Object.assign(item, videoInfo);
            history.unshift(item);
          } else {
            videoInfo.url = window.location.href;
            history.unshift(videoInfo);
          }
          if (history.length > 50) history.splice(50);
          localStorage.setItem('viewingHistory', JSON.stringify(history));
        } catch (e) {}
      }
    }
    function showError(msg) {
      if (state.dp && state.dp.video && state.dp.video.currentTime > 1) return;
      qs('loading').style.display = 'none';
      qs('error').style.display = 'flex';
      qs('error-message').textContent = msg;
    }
    function saveCurrentProgress() {
      if (!state.dp || !state.dp.video) return;
      const currentTime = state.dp.video.currentTime, duration = state.dp.video.duration;
      if (!duration || currentTime < 1) return;
      const progressKey = `videoProgress_${getVideoId()}`;
      const progressData = { position: currentTime, duration, timestamp: Date.now() };
      try {
        localStorage.setItem(progressKey, JSON.stringify(progressData));
      } catch {}
    }
    function clearVideoProgress() {
      try { localStorage.removeItem(`videoProgress_${getVideoId()}`); } catch {}
    }
    function startProgressSaveTimer() {
      removeProgressSaveTimer();
      state.progressSaveInterval = setInterval(saveCurrentProgress, 30000);
    }
    function removeProgressSaveTimer() {
      if (state.progressSaveInterval) clearInterval(state.progressSaveInterval);
      state.progressSaveInterval = null;
    }
    function subscribeVideoEvents() {
      const check = setInterval(() => {
        if (state.dp && state.dp.video) {
          state.dp.video.addEventListener('pause', saveCurrentProgress);
          let lastSave = 0;
          state.dp.video.addEventListener('timeupdate', function () {
            const now = Date.now();
            if (now - lastSave > 5000) { saveCurrentProgress(); lastSave = now; }
          });
          clearInterval(check);
        }
      }, 200);
    }
    // ========== 进度条、定位恢复等 ==========
    function setupProgressBarPreciseClicks() {
      const bar = document.querySelector('.dplayer-bar-wrap');
      if (!bar || !state.dp || !state.dp.video) return;
      bar.removeEventListener('mousedown', handleProgressBarClick);
      bar.addEventListener('mousedown', handleProgressBarClick);
      bar.removeEventListener('touchstart', handleProgressBarTouch);
      bar.addEventListener('touchstart', handleProgressBarTouch);
    }
    function handleProgressBarClick(e) {
      if (!state.dp || !state.dp.video) return;
      const rect = e.currentTarget.getBoundingClientRect();
      const percentage = (e.clientX - rect.left) / rect.width;
      const duration = state.dp.video.duration;
      let clickTime = percentage * duration;
      if (duration - clickTime < 1) clickTime = Math.min(clickTime, duration - 1.5);
      state.userClickedPosition = clickTime;
      e.stopPropagation();
      state.dp.seek(clickTime);
    }
    function handleProgressBarTouch(e) {
      if (!state.dp || !state.dp.video || !e.touches[0]) return;
      const touch = e.touches[0];
      const rect = e.currentTarget.getBoundingClientRect();
      const percentage = (touch.clientX - rect.left) / rect.width;
      const duration = state.dp.video.duration;
      let clickTime = percentage * duration;
      if (duration - clickTime < 1) clickTime = Math.min(clickTime, duration - 1.5);
      state.userClickedPosition = clickTime;
      e.stopPropagation();
      state.dp.seek(clickTime);
    }
    function showPositionRestoreHint(position) {
      if (!position || position < 10) return;
      const hint = document.createElement('div');
      hint.className = 'position-restore-hint';
      hint.innerHTML = `<div class="hint-content">已从 ${formatTime(position)} 继续播放</div>`;
      document.querySelector('.player-container').appendChild(hint);
      setTimeout(() => {
        hint.classList.add('show');
        setTimeout(() => {
          hint.classList.remove('show');
          setTimeout(() => hint.remove(), 300);
        }, 3000);
      }, 100);
    }
    function onVisibilityChange() {
      if (document.visibilityState === 'hidden') saveCurrentProgress();
    }
    function updateQueryUrl(obj) {
      const url = new URL(window.location.href);
      Object.entries(obj).forEach(([k, v]) => url.searchParams.set(k, v));
      return url;
    }
    // ========== Toast 简易通知 ==========
    window.showToast = function(msg, type = 'error') {
      let existingToast = document.getElementById('custom-toast');
      if (existingToast) existingToast.remove();
      const toast = document.createElement('div');
      toast.id = 'custom-toast';
      toast.style.position = 'fixed'; toast.style.top = '20px'; toast.style.left = '50%';
      toast.style.transform = 'translateX(-50%)';
      toast.style.backgroundColor = type === 'error' ? '#f44336' : '#4caf50';
      toast.style.color = 'white'; toast.style.padding = '12px 20px';
      toast.style.borderRadius = '4px'; toast.style.zIndex = '10000'; toast.style.boxShadow = '0 2px 8px rgba(0,0,0,0.3)';
      toast.style.opacity = '0'; toast.style.transition = 'opacity 0.3s ease-in-out';
      toast.textContent = msg;
      document.body.appendChild(toast);
      setTimeout(() => {
        toast.style.opacity = '1'; setTimeout(() => {
          toast.style.opacity = '0'; setTimeout(() => toast.remove(), 300);
        }, 3000);
      }, 10);
    };
    window.playEpisode = window.playEpisode;
    window.playPreviousEpisode = window.playPreviousEpisode;
    window.playNextEpisode = window.playNextEpisode;
    window.toggleEpisodeOrder = window.toggleEpisodeOrder;
    window.toggleControlsLock = window.toggleControlsLock;

    // ==== 集数预加载/极致快切部分 ====
    // ======== 预加载多集（m3u8和前3个ts分片）极致快切方案 ========
    // 代码与原始player-preload保持一致
    // ==== 集数预加载/极致快切部分 ====
    // 配置：预加载开关，参见 config.js 需设定 PLAYER_CONFIG.enablePreloading = true/false
    (function () {
      const PRELOAD_EPISODE_COUNT = 2;
      const supportsCacheStorage = 'caches' in window && window.caches.open;
      function isSlowNetwork() {
        const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
        if (!connection || !connection.effectiveType) return false;
        return /2g|slow-2g/.test(connection.effectiveType);
      }
      /**
       * 预加载下若干集（m3u8和前3个ts分片），支持详细日志和异常兜底
       */
      async function preloadNextEpisodeParts(preloadCount = PRELOAD_EPISODE_COUNT) {
        // 全局配置是否启用
        if (!(typeof PLAYER_CONFIG !== "undefined" && PLAYER_CONFIG.enablePreloading)) {
          if (state.debugMode) console.log('[Preload] 跳过，因PLAYER_CONFIG.enablePreloading=false');
          return;
        }
        if (isSlowNetwork()) {
          if (state.debugMode) console.log('[Preload] 跳过，因网络过慢');
          return;
        }
        if (!window.currentEpisodes || typeof window.currentEpisodeIndex !== 'number') {
          if (state.debugMode) console.log('[Preload] 跳过，window.currentEpisodes/currentEpisodeIndex缺失');
          return;
        }
        const idx = window.currentEpisodeIndex, maxIndex = window.currentEpisodes.length - 1;
        if (state.debugMode) console.log(`[Preload] 尝试预加载从${idx+1}到${Math.min(idx+preloadCount, maxIndex)}集`);
        for (let offset = 1; offset <= preloadCount; offset++) {
          const episodeIdx = idx + offset;
          if (episodeIdx > maxIndex) break;
          const nextUrl = window.currentEpisodes[episodeIdx];
          if (state.debugMode) console.log(`[Preload] 检查第${episodeIdx+1}集(${nextUrl})`);
          if (!nextUrl || typeof nextUrl !== 'string') {
            if (state.debugMode) console.log(`[Preload] 略过空URL@${episodeIdx}`);
            continue;
          }
          try {
            const m3u8Resp = await fetch(nextUrl, { method: "GET", credentials: "same-origin" });
            if (!m3u8Resp.ok) {
              if (state.debugMode) console.log(`[Preload] m3u8请求失败: ${nextUrl}`);
              continue;
            }
            const m3u8Text = await m3u8Resp.text();
            const tsUrls = [];
            let base = nextUrl.substring(0, nextUrl.lastIndexOf('/') + 1);
            m3u8Text.split('\n').forEach(line => {
              const t = line.trim();
              if (t && !t.startsWith("#") && /\.ts(\?|$)/i.test(t) && tsUrls.length < 3) {
                tsUrls.push(/^https?:\/\//i.test(t) ? t : base + t);
              }
            });
            if (state.debugMode) console.log(`[Preload] m3u8分析结果: ts=${tsUrls.length}`);
            if (tsUrls.length === 0) continue;
            tsUrls.forEach(tsUrl => {
              if (supportsCacheStorage) {
                caches.open('libretv-preload1').then(cache => {
                  cache.match(tsUrl).then(cachedResp => {
                    if (!cachedResp) {
                      fetch(tsUrl, { method: "GET", credentials: "same-origin" }).then(resp => {
                        if (resp.ok) {
                          cache.put(tsUrl, resp.clone());
                          if (state.debugMode) console.log(`[Preload] ts分片已缓存: ${tsUrl}`);
                        } else if (state.debugMode) {
                          console.log(`[Preload] ts分片拉取失败: ${tsUrl}`);
                        }
                      }).catch(ex => {
                        if (state.debugMode) console.log(`[Preload] ts fetch异常: ${tsUrl} e=${ex}`);
                      });
                    } else {
                      if (state.debugMode) console.log(`[Preload] ts分片已存在缓存: ${tsUrl}`);
                    }
                  });
                });
              } else {
                fetch(tsUrl, { method: "GET", credentials: "same-origin" }).then(resp => {
                  if (state.debugMode) {
                    if (resp.ok) console.log(`[Preload] ts分片已拉取(无缓存): ${tsUrl}`);
                    else console.log(`[Preload] ts分片拉取失败: ${tsUrl}`);
                  }
                }).catch(ex => {
                  if (state.debugMode) console.log(`[Preload] ts fetch异常(无缓存): ${tsUrl} e=${ex}`);
                });
              }
            });
          } catch (e) {
            if (state.debugMode) console.log(`[Preload] m3u8拉取/处理异常: ${nextUrl}; e=${e}`);
          }
        }
      }
      // 挂到window以兼容部分外部依赖，但主逻辑已按配置集成
      window.preloadNextEpisodeParts = preloadNextEpisodeParts;

      document.addEventListener('DOMContentLoaded', function () {
        // 只在允许预加载时注册全部事件
        if (!(typeof PLAYER_CONFIG !== "undefined" && PLAYER_CONFIG.enablePreloading)) return;

        // 1. 鼠标悬停/触摸“下一集”按钮预加载
        var nextBtn = document.getElementById('nextButton');
        if (nextBtn) {
          nextBtn.addEventListener('mouseenter', () => preloadNextEpisodeParts(PRELOAD_EPISODE_COUNT), { passive: true });
          nextBtn.addEventListener('touchstart', () => preloadNextEpisodeParts(PRELOAD_EPISODE_COUNT), { passive: true });
        }
        // 2. 当前视频播到结尾前，预拉后3集
        function setupTimeupdatePreload() {
          if (window.dp && window.dp.video && typeof window.dp.video.addEventListener === 'function') {
            window.dp.video.addEventListener('timeupdate', () => {
              if (
                window.dp.video.duration &&
                window.dp.video.currentTime > window.dp.video.duration - 12
              ) {
                preloadNextEpisodeParts(PRELOAD_EPISODE_COUNT);
              }
            });
          }
        }
        if (window.dp && window.dp.video) {
          setupTimeupdatePreload();
        } else {
          var tries = 0;
          var timer = setInterval(() => {
            if (window.dp && window.dp.video) {
              setupTimeupdatePreload();
              clearInterval(timer);
            }
            if (++tries > 50) clearInterval(timer);
          }, 200);
        }
        // 3. 点击任何集数按钮均预拉后3集
        var episodesList = document.getElementById('episodesList');
        if (episodesList) {
          episodesList.addEventListener('click', function (e) {
            var btn = e.target.closest('button[id^="episode-"]');
            if (btn) {
              setTimeout(function () {
                if (typeof window.preloadNextEpisodeParts === 'function') {
                  window.preloadNextEpisodeParts(PRELOAD_EPISODE_COUNT);
                }
              }, 200);
            }
          });
        }
      });
    })();
    // ==== 结束 ====
  })();
  </script>
</body>
</html>
